import React, { useState, useEffect } from 'react';
import { Card, CardHeader, Button, TextArea, CopyButton, Select, Label } from '../components/ui/Shared';
import { TrashIcon, TableIcon } from '../components/ui/Icons';
import { useAppContext } from '../contexts/AppContext';
import { useNavigate } from 'react-router-dom';
import Papa from 'papaparse';
import { convert, detectFormat, FormatType, jsonToXml as utilJsonToXml, yamlToJson, xmlToJson } from '../utils/converters';

// --- Converter Tools Component ---
export const ConverterTools: React.FC = () => {
  const [input, setInput] = useState('');
  const [output, setOutput] = useState('');
  // modes: format (default/auto), toTS, toGo, toJava, toCSV, minify
  const [mode, setMode] = useState('format');
  const [sourceFormat, setSourceFormat] = useState<FormatType>('json');
  const [targetFormat, setTargetFormat] = useState<FormatType>('json');
  const [error, setError] = useState<string | null>(null);
  const { t } = useAppContext();
  const navigate = useNavigate();

  const handleAutoDetect = () => {
    if (!input.trim()) return;
    const detected = detectFormat(input);
    if (detected) {
      setSourceFormat(detected);
    }
  };

  // Effect for Auto Detect on load or input change if sourceFormat is JSON and input looks like something else?
  // Requirement says: "Automatic format detection function: Identify format type based on input string".
  // I will add a manual button for it, or check if it matches current selection.
  // For now, keeping manual button logic, but maybe update sourceFormat if it clearly mismatches?
  // Let's stick to the manual "Auto Detect" button for explicit action, or automatic update if user hasn't touched the dropdown?
  // I'll stick to the manual button for now as implemented in handleAutoDetect.

  // Primary Conversion Logic
  useEffect(() => {
    if (!input.trim()) {
      setOutput('');
      setError(null);
      return;
    }

    // Special handling for legacy modes that expect JSON input only
    if (['toTS', 'toGo', 'toJava', 'toCSV'].includes(mode)) {
        try {
             // Try to parse input as JSON first.
             // If source format is NOT json, we should probably convert it to json first?
             // But existing logic assumes input is JSON string.
             // Let's support other formats by converting to JSON intermediate first.
             let intermediate: any;
             try {
                if (sourceFormat === 'json') intermediate = JSON.parse(input);
                else if (sourceFormat === 'yaml') intermediate = yamlToJson(input);
                else if (sourceFormat === 'xml') intermediate = xmlToJson(input);
             } catch(e) {
                 // Fallback: try parsing as JSON if sourceFormat was wrong
                 intermediate = JSON.parse(input);
             }

             setError(null);
             switch (mode) {
                case 'toTS': setOutput(jsonToTypeScript(intermediate)); break;
                case 'toGo': setOutput(jsonToGo(intermediate)); break;
                case 'toJava': setOutput(jsonToJava(intermediate)); break;
                case 'toCSV': setOutput(jsonToCsv(intermediate)); break;
             }
        } catch (e) {
             setError((e as Error).message);
        }
        return;
    }

    if (mode === 'minify') {
        try {
            // Minify only makes sense for JSON usually, but we can do it for others by re-stringifying with 0 indent
             const result = convert(input, sourceFormat, targetFormat, { indent: 0 });
             setOutput(result);
             setError(null);
        } catch(e) {
            setError((e as Error).message);
        }
        return;
    }

    // Default 'format' mode: Use the convert utility
    try {
      const result = convert(input, sourceFormat, targetFormat, { indent: 2 });
      setOutput(result);
      setError(null);
    } catch (e) {
      setError((e as Error).message);
    }
  }, [input, mode, sourceFormat, targetFormat]);


  // Converters (Legacy / Special)
  const jsonToTypeScript = (obj: any, name = "Root"): string => {
    const getType = (v: any): string => Array.isArray(v) ? `${getType(v[0])}[]` : typeof v === 'object' && v !== null ? 'object' : typeof v;
    return `interface ${name} {\n` + Object.keys(obj).map(k => `  ${k}: ${getType(obj[k])};`).join('\n') + `\n}`;
  };
  const jsonToGo = (obj: any, name = "AutoGenerated"): string => {
    return `type ${name} struct {\n` + Object.keys(obj).map(k => 
        `\t${k.charAt(0).toUpperCase() + k.slice(1)} ${typeof obj[k] === 'number' ? 'float64' : 'string'} \`json:"${k}"\``
    ).join('\n') + `\n}`;
  };
  const jsonToJava = (obj: any, name = "AutoGenerated"): string => {
      return `public class ${name} {\n` + Object.keys(obj).map(k => 
        `    private ${typeof obj[k] === 'number' ? 'double' : 'String'} ${k};`
      ).join('\n') + `\n    // Getters and Setters omitted\n}`;
  };
  const jsonToCsv = (obj: any): string => {
      const arr = Array.isArray(obj) ? obj : [obj];
      if (arr.length === 0) return '';
      return Papa.unparse(arr);
  }

  const handleDownloadCsv = () => {
      if (!output) return;
      const blob = new Blob([output], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'converted.csv';
      link.click();
  };

  const handleOpenInCsvTool = () => {
      if (!input) return;
      try {
          // Attempt to get data based on current source format
          let data: any;
           if (sourceFormat === 'json') data = JSON.parse(input);
           else if (sourceFormat === 'yaml') data = yamlToJson(input);
           else if (sourceFormat === 'xml') data = xmlToJson(input);

          data = Array.isArray(data) ? data : [data];
          navigate('/csv', { state: { data } });
      } catch(e) {
          // ignore
      }
  };

  return (
    <div className="space-y-6 h-[calc(100vh-4rem)] flex flex-col">
      <div>
        <h2 className="text-2xl font-bold text-slate-800 dark:text-white">{t('tool.converter.title')}</h2>
        <p className="text-slate-500 dark:text-slate-400">{t('tool.converter.desc')}</p>
      </div>

      <div className="flex flex-wrap gap-2 bg-slate-100 dark:bg-slate-800 p-2 rounded-lg border border-slate-200 dark:border-slate-700">
        {[
          {id: 'format', l: t('tool.converter.format')},
          {id: 'minify', l: t('tool.json.minify')},
          {id: 'toTS', l: t('tool.json.toTS')},
          {id: 'toGo', l: t('tool.json.toGo')},
          {id: 'toJava', l: t('tool.json.toJava')},
          // Removed toXML/toYAML buttons as they are now handled by dropdowns, but keeping toCSV as it's a specific export
          {id: 'toCSV', l: t('tool.json.toCSV')}
        ].map((m) => (
          <button key={m.id} onClick={() => setMode(m.id)} className={`px-3 py-1.5 text-xs font-medium rounded-md transition-all ${mode === m.id ? 'bg-blue-600 text-white shadow' : 'text-slate-500 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white hover:bg-slate-200 dark:hover:bg-slate-700'}`}>{m.l}</button>
        ))}
      </div>

      {/* Main Conversion Area */}
      <div className="space-y-4 flex-1 flex flex-col min-h-0">

          {/* Format Selection (Only show if not in legacy code generation modes) */}
          {['format', 'minify'].includes(mode) && (
            <div className="flex flex-wrap gap-4 items-end">
                <div className="flex-1 min-w-[200px]">
                <Label className="block mb-2 text-sm font-medium">{t('tool.json.sourceFormat')}</Label>
                <Select value={sourceFormat} onChange={(e) => setSourceFormat(e.target.value as FormatType)}>
                    <option value="json">JSON</option>
                    <option value="yaml">YAML</option>
                    <option value="xml">XML</option>
                </Select>
                </div>
                <div className="flex-1 min-w-[200px]">
                <Label className="block mb-2 text-sm font-medium">{t('tool.json.targetFormat')}</Label>
                <Select value={targetFormat} onChange={(e) => setTargetFormat(e.target.value as FormatType)}>
                    <option value="json">JSON</option>
                    <option value="yaml">YAML</option>
                    <option value="xml">XML</option>
                </Select>
                </div>
                <Button onClick={handleAutoDetect} variant="secondary" className="text-xs">
                    {t('tool.json.autoDetect')}
                </Button>
            </div>
          )}

          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 flex-1 min-h-0">
            <Card className="flex flex-col h-full">
              <CardHeader title={`${t('tool.json.input')} ${['format', 'minify'].includes(mode) ? `(${sourceFormat.toUpperCase()})` : ''}`} action={input && <button onClick={() => { setInput(''); setOutput(''); }} className="text-slate-400 hover:text-red-400"><TrashIcon className="w-4 h-4" /></button>} />
              <div className="flex-1 p-2 bg-slate-50 dark:bg-slate-900">
                <TextArea value={input} onChange={(e) => setInput(e.target.value)} placeholder={sourceFormat === 'json' ? '{"key": "value"}' : sourceFormat === 'yaml' ? 'key: value' : '<root><key>value</key></root>'} className="w-full h-full border-0 bg-transparent text-slate-900 dark:text-white resize-none p-2 font-mono text-sm" spellCheck={false} />
              </div>
            </Card>
            <Card className="flex flex-col h-full border-blue-900/30">
              <CardHeader title={error ? t('tool.json.error') : `${t('tool.json.output')} ${['format', 'minify'].includes(mode) ? `(${targetFormat.toUpperCase()})` : ''}`} action={
                  <div className="flex items-center gap-2">
                    {mode === 'toCSV' && !error && output && (
                        <>
                          <Button size="sm" variant="secondary" onClick={handleOpenInCsvTool} className="text-xs" title={t('tool.json.openCsv')}>
                             <TableIcon className="w-4 h-4" />
                          </Button>
                          <Button size="sm" variant="secondary" onClick={handleDownloadCsv} className="text-xs">
                             {t('tool.csv.download')}
                          </Button>
                        </>
                    )}
                    <CopyButton text={output} />
                  </div>
              } />
              <div className="flex-1 p-0 bg-slate-100 dark:bg-slate-950 overflow-hidden relative">
                 {error ? <div className="p-4 text-red-500 dark:text-red-400 font-mono text-sm">{error}</div> :
                 <TextArea readOnly value={output} className="w-full h-full border-0 bg-transparent resize-none p-4 font-mono text-emerald-600 dark:text-emerald-400 text-sm" />}
              </div>
            </Card>
          </div>
        </div>
    </div>
  );
};

// Also export JsonTools for backward compatibility if needed, but we can replace it.
// The task says "Refactor JsonTools to ConverterTools".
// I will export ConverterTools as JsonTools as well to avoid breaking imports in other files if any (though likely only App.tsx)
export const JsonTools = ConverterTools;


// --- Code Format Tools ---
export const CodeTools: React.FC = () => {
  const [codeInput, setCodeInput] = useState('');
  const [codeLang, setCodeLang] = useState('html');
  const [codeOutput, setCodeOutput] = useState('');
  const { t } = useAppContext();

  useEffect(() => {
      if (!codeInput) { setCodeOutput(''); return; }
      if (codeLang === 'html') {
        setCodeOutput(codeInput.replace(/>\s*</g, ">\n<").replace(/(<[a-zA-Z0-9]+[^>]*>)/g, "$1\n").replace(/(<\/[a-zA-Z0-9]+>)/g, "\n$1"));
      } else if (codeLang === 'sql') {
        setCodeOutput(codeInput.replace(/\b(SELECT|FROM|WHERE|AND|OR|ORDER BY|GROUP BY|INSERT|UPDATE|DELETE)\b/gi, "\n$1"));
      } else if (codeLang === 'css') {
        setCodeOutput(codeInput.replace(/;/g, ";\n  ").replace(/{/g, " {\n  ").replace(/}/g, "\n}\n"));
      } else {
        setCodeOutput(codeInput);
      }
  }, [codeInput, codeLang]);

  return (
    <div className="space-y-6 h-[calc(100vh-4rem)] flex flex-col">
      <div>
        <h2 className="text-2xl font-bold text-slate-800 dark:text-white">{t('tool.code.title')}</h2>
        <p className="text-slate-500 dark:text-slate-400">{t('tool.code.desc')}</p>
      </div>
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 flex-1 min-h-0">
        <Card className="flex flex-col h-full">
          <div className="px-6 py-4 border-b border-slate-200 dark:border-slate-700 bg-slate-50/50 dark:bg-slate-800/50 flex justify-between items-center">
              <h3 className="font-semibold text-slate-800 dark:text-white">{t('tool.code.input')}</h3>
              <div className="w-32"><Select value={codeLang} onChange={(e) => setCodeLang(e.target.value)}><option value="html">HTML</option><option value="sql">SQL</option><option value="css">CSS</option></Select></div>
          </div>
          <TextArea value={codeInput} onChange={(e) => setCodeInput(e.target.value)} className="flex-1 w-full border-0 bg-slate-50 dark:bg-slate-900 text-slate-900 dark:text-white p-4 resize-none font-mono text-sm" placeholder={t('tool.code.paste')} spellCheck={false} />
        </Card>
        <Card className="flex flex-col h-full border-blue-900/30">
            <CardHeader title={t('tool.code.output')} action={<CopyButton text={codeOutput} />} />
            <TextArea readOnly value={codeOutput} className="flex-1 w-full border-0 bg-slate-100 dark:bg-slate-950 p-4 resize-none font-mono text-blue-600 dark:text-blue-300 text-sm" />
        </Card>
      </div>
    </div>
  );
};

// --- Encoder Tools ---
export const EncoderTools: React.FC = () => {
  const [encodeInput, setEncodeInput] = useState('');
  const [encodeMode, setEncodeMode] = useState('base64_enc');
  const [encodeOutput, setEncodeOutput] = useState('');
  const { t } = useAppContext();

  const stringToHex = (str: string) => str.split('').map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ');
  const hexToString = (str: string) => str.replace(/\s/g,'').match(/.{1,2}/g)?.map(byte => String.fromCharCode(parseInt(byte, 16))).join('') || '';

  useEffect(() => {
    if (!encodeInput) { setEncodeOutput(''); return; }
    try {
        let res = '';
        switch(encodeMode) {
            case 'base64_enc': res = btoa(encodeInput); break;
            case 'base64_dec': res = atob(encodeInput); break;
            case 'url_enc': res = encodeURIComponent(encodeInput); break;
            case 'url_dec': res = decodeURIComponent(encodeInput); break;
            case 'hex_bin': res = stringToHex(encodeInput); break;
            case 'bin_hex': res = hexToString(encodeInput); break;
        }
        setEncodeOutput(res);
    } catch(e) { setEncodeOutput("Conversion Error"); }
  }, [encodeInput, encodeMode]);

  return (
    <div className="space-y-6 h-[calc(100vh-4rem)] flex flex-col">
       <div>
        <h2 className="text-2xl font-bold text-slate-800 dark:text-white">{t('tool.encoder.title')}</h2>
        <p className="text-slate-500 dark:text-slate-400">{t('tool.encoder.desc')}</p>
      </div>

      <div className="flex flex-wrap gap-2 bg-slate-100 dark:bg-slate-800 p-2 rounded-lg border border-slate-200 dark:border-slate-700">
        {[
            {id: 'base64_enc', l: t('tool.encoder.base64_enc')},
            {id: 'base64_dec', l: t('tool.encoder.base64_dec')},
            {id: 'url_enc', l: t('tool.encoder.url_enc')},
            {id: 'url_dec', l: t('tool.encoder.url_dec')},
            {id: 'hex_bin', l: t('tool.encoder.hex_bin')},
            {id: 'bin_hex', l: t('tool.encoder.bin_hex')}
        ].map((m) => (
          <button key={m.id} onClick={() => setEncodeMode(m.id)} className={`px-3 py-1.5 text-xs font-medium rounded-md transition-all ${encodeMode === m.id ? 'bg-blue-600 text-white shadow' : 'text-slate-500 dark:text-slate-400 hover:text-slate-900 dark:hover:text-white hover:bg-slate-200 dark:hover:bg-slate-700'}`}>{m.l}</button>
        ))}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 flex-1 min-h-0">
        <Card className="flex flex-col h-full">
            <CardHeader title={t('tool.encoder.input')} action={encodeInput && <button onClick={() => { setEncodeInput(''); setEncodeOutput(''); }} className="text-slate-400 hover:text-red-400"><TrashIcon className="w-4 h-4" /></button>} />
            <div className="flex-1 p-2 bg-slate-50 dark:bg-slate-900">
                <TextArea value={encodeInput} onChange={(e) => setEncodeInput(e.target.value)} className="w-full h-full border-0 bg-transparent text-slate-900 dark:text-white resize-none p-2 font-mono text-sm" placeholder={t('tool.encoder.type')} />
            </div>
        </Card>
        <Card className="flex flex-col h-full border-blue-900/30">
            <CardHeader title={t('tool.encoder.result')} action={<CopyButton text={encodeOutput} />} />
            <div className="flex-1 p-0 bg-slate-100 dark:bg-slate-950 overflow-hidden relative">
                <TextArea readOnly value={encodeOutput} className="w-full h-full border-0 bg-transparent resize-none p-4 font-mono text-emerald-600 dark:text-emerald-400 text-sm" />
            </div>
        </Card>
      </div>
    </div>
  );
};
